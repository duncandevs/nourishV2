import { asyncFetchOpenAICompletion } from "../../clients/openAiClient";
import { FetchMethod } from '../types';
import SearchService from '../../domains/search/services';
import FoodService from '../../domains/food/services';
import { Food } from "../../domains/food/types";
import { FoodLog } from "../foodLog/types";
import { getRoundedMacros } from "../../utility";
import { Macros } from "../foodLog/types";

// const completionResponse = async (prompt: string) => 
//     await openAiClient.completions.create({ model: MODEL, prompt, max_tokens:512, temperature: 0 });

/*
    NOTES on caching recent results 
        1. grab the first 50 foods generated by the user
        2. cache them locally on the device
        3. use auto completion feature on the items before performing any supabase look-ups
        4. beware of time complexity in <Array> vs <Object> especially with lookUps
*/

type AIResults = Macros & {
    name: string;
};

const MAX_RETRIES = 3;

const isValidData = (data) => {
    // Add validation logic for your data here, for example:
    return data && typeof data === 'object' && data.name && data.calories;
};

const getOpenAISearchPromptResult = async (searchTerm: string, retryCount: number = 0): Promise<FetchMethod> => {
    try {
        const response = await asyncFetchOpenAICompletion({ searchTerm });
        const generatedText = response?.choices?.[0]?.message?.function_call?.arguments;
        const data: AIResults  = generatedText ? JSON.parse(generatedText) : null;
        
        // Check if the data is valid
        if (!isValidData(data)) {
            // If not valid and we haven't reached our max retries, retry the function
            if (retryCount < MAX_RETRIES) {
                return getOpenAISearchPromptResult(searchTerm, retryCount + 1);
            } else {
                // TODO: log the error
                // Max retries reached, return an error
                return { data: null, error: 'Maximum retries reached and data is still invalid.' };
            }
        }

        if(data) data.name = searchTerm;
        
        return { data, error: null };
    } catch (error) {
        return { data: null, error };
    }
};

type UseAISearchResult = Promise<{data: Food | null, error:string | null}> 

export const useFoodSearch = async ({ recents, searchTerm } : {recents: FoodLog[] | null | undefined, searchTerm: string }): UseAISearchResult => {
    let foodParams: AIResults | null = null
    let error: string | null = null;
    const foodName = searchTerm.trim().toLocaleLowerCase();
    // check if food exists in recent logs;
    const recentFoodLog = recents?.find((item)=>item.food.name === foodName);
    if(recentFoodLog) foodParams = recentFoodLog?.food;

    // check if food is in the db
    if(!recentFoodLog){
      const { data, error: fetchFoodError }= await FoodService.fetchFoodByName({ foodName });
      if(data) foodParams = data
    };

    // get ai search result
    if(!foodParams) {
        const {data: newFood, error: searchError} = await SearchService.getOpenAISearchPromptResult(foodName);
        foodParams = newFood;
        if(searchError) error = searchError;
    };

    // round off the macros
    if(foodParams) {
        foodParams = {
            ...foodParams,
            ...getRoundedMacros(foodParams)
        };
    };
    return { data: foodParams, error }
}

export default {
    getOpenAISearchPromptResult,
    useFoodSearch,
}