import { asyncFetchOpenAICompletion } from "../../clients/openAiClient";
import { FetchMethod } from '../types';
import SearchService from '../../domains/search/services';
import FoodService from '../../domains/food/services';
import { Food } from "../../domains/food/types";
import { FoodLog } from "../foodLog/types";
import { fetchGoogleAIResult } from "../../clients/googleClient"

// const completionResponse = async (prompt: string) => 
//     await openAiClient.completions.create({ model: MODEL, prompt, max_tokens:512, temperature: 0 });

/*
    NOTES on caching recent results 
        1. grab the first 50 foods generated by the user
        2. cache them locally on the device
        3. use auto completion feature on the items before performing any supabase look-ups
        4. beware of time complexity in <Array> vs <Object> especially with lookUps
*/

const MAX_RETRIES = 3;

const isValidData = (data: any) => {
    // Add validation logic for your data here, for example:
    return data && typeof data === 'object' &&  data.calories && data.fat && data.protein && data.carbs;
};

const getOpenAISearchResult = async (searchTerm: string, retryCount: number = 0): Promise<FetchMethod> => {
    try {
        const response = await asyncFetchOpenAICompletion({ searchTerm });
        const generatedText = response?.choices?.[0]?.message?.function_call?.arguments;
        const data = generatedText ? JSON.parse(generatedText) : null;
        
        // Check if the data is valid
        if (!isValidData(data)) {
            // If not valid and we haven't reached our max retries, retry the function
            if (retryCount < MAX_RETRIES) {
                return getOpenAISearchResult(searchTerm, retryCount + 1);
            } else {
                // TODO: log the error
                // Max retries reached, return an error
                return { data: null, error: 'Maximum retries reached and data is still invalid.' };
            }
        }
        // set data name with search term
        if(data) data.name = searchTerm;
        
        return { data, error: null };
    } catch (error) {
        return { data: null, error };
    }
};

const getGoogleAISearchResult = async (searchTerm: string) => {
    try {
        let retryCount = 0
        const data = await fetchGoogleAIResult(searchTerm);
        if(!isValidData(data)){
            if (retryCount < MAX_RETRIES) {
                return getOpenAISearchResult(searchTerm, retryCount + 1);
            } else {
                // TODO: log the error
                // Max retries reached, return an error
                return { data: null, error: 'Maximum retries reached and data is still invalid.' };
            }
        }
        return { data, error: null };
    } catch (error) {
        return { error, data: null };
    }
}

type UseAISearchResult = Promise<{data: Food | null, error:string | null}> 

export const useFoodSearch = async ({ recents, searchTerm } : {recents: FoodLog[] | null | undefined, searchTerm: string }): UseAISearchResult => {
    let food: Food | null = null;
    let error: string | null = null;
    const foodName = searchTerm.trim().toLocaleLowerCase();
    // check if food exists in recent logs;
    const recentFoodLog = recents?.find((item)=>item.food.name === foodName);
    if(recentFoodLog) food = recentFoodLog?.food;

    // check if food is in the db
    if(!recentFoodLog){
      const { data, error: fetchFoodError }= await FoodService.fetchFoodByName({ foodName });
      if(data) food = data
    };

    // get ai search result
    if(!food) {
      const {data: newFood, error: searchError} = await SearchService.getGoogleAISearchResult(foodName);
      food = newFood;
      if(searchError) error = searchError;
    };

    return { data: food, error }
}

export default {
    getGoogleAISearchResult,
    useFoodSearch,
}