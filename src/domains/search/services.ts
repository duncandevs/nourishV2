import { fetchGptByText, fetchGptByImage } from "../../clients/openAiClient";
import { FetchMethod } from '../types';
import SearchService from '../../domains/search/services';
import FoodService from '../../domains/food/services';
import { Food } from "../../domains/food/types";
import { FoodLog } from "../foodLog/types";

// const completionResponse = async (prompt: string) => 
//     await openAiClient.completions.create({ model: MODEL, prompt, max_tokens:512, temperature: 0 });

/*
    NOTES on caching recent results 
        1. grab the first 50 foods generated by the user
        2. cache them locally on the device
        3. use auto completion feature on the items before performing any supabase look-ups
        4. beware of time complexity in <Array> vs <Object> especially with lookUps
*/

const MAX_RETRIES = 3;

const isValidData = (data) => {
    // Add validation logic for your data here, for example:
    return data && typeof data === 'object' && data.name && data.calories;
};

const getAISearchResultByText = async (searchTerm: string, retryCount: number = 0): Promise<FetchMethod> => {
    try {
        const response = await fetchGptByText({ searchTerm });
        const generatedText = response?.choices?.[0]?.message?.function_call?.arguments;
        const data = generatedText ? JSON.parse(generatedText) : null;
        
        // Check if the data is valid
        if (!isValidData(data)) {
            // If not valid and we haven't reached our max retries, retry the function
            if (retryCount < MAX_RETRIES) {
                return getAISearchResultByText(searchTerm, retryCount + 1);
            } else {
                // TODO: log the error
                // Max retries reached, return an error
                return { data: null, error: 'Maximum retries reached and data is still invalid.' };
            }
        }
        // set data name with search term
        if(data) data.name = searchTerm;
        
        return { data, error: null };
    } catch (error) {
        return { data: null, error };
    }
};

const getAISearchPromptByImage = async  ({ base64Image }: {base64Image: string}) => {
    try {
        const response = await fetchGptByImage(base64Image);
        console.log('response - ', response)
        const prompt = response?.choices[0]?.message?.content;
        if(prompt) return { data: prompt, error: null}
        return { data: null, error: 'Internal server error'}
    } catch (error) {
        return { data: null, error: 'Internal server error' }
    };
};

const getAISearchResultByImage = async ({ base64Image }: {base64Image: string}) => {
    try {
        const response = await fetchGptByImage(base64Image);
        const prompt = response?.choices[0]?.message?.content;
        console.log('image food prompt - ', prompt);
        if(prompt) {
            const {data, error} = await getAISearchResultByText(prompt, 2);
            console.log({data, error})
            if(data) data.name = prompt; // set data name with search term
            if(data) return { data, error: null }
            if(error) return { data: null, error }
        };
        return { data: null, error: 'Could not generate prompt'}
    } catch (error) {
        return { data: null, error }
    }
}

type UseAISearchResult = Promise<{data: Food | null, error:string | null}> 

export const useFoodSearch = async ({ recents, searchTerm } : {recents: FoodLog[] | null | undefined, searchTerm: string }): UseAISearchResult => {
    let food: Food | null = null;
    let error: string | null = null;
    const foodName = searchTerm.trim().toLocaleLowerCase();
    // check if food exists in recent logs;
    const recentFoodLog = recents?.find((item)=>item.food.name === foodName);
    if(recentFoodLog) food = recentFoodLog?.food;

    // check if food is in the db
    if(!recentFoodLog){
      const { data, error: fetchFoodError }= await FoodService.fetchFoodByName({ foodName });
      if(data) food = data
    };

    // get ai search result
    if(!food) {
      const {data: newFood, error: searchError} = await SearchService.getAISearchResultByText(foodName);
      food = newFood;
      if(searchError) error = searchError;
    };

    return { data: food, error }
}

export default {
    getAISearchResultByText,
    getAISearchResultByImage,
    getAISearchPromptByImage,
    useFoodSearch,
}