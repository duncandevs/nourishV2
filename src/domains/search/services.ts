import { fetchGptByText, fetchGptByImage } from "../../clients/openAiClient";
import { FetchMethod } from '../types';
import FoodService from '../../domains/food/services';
import { Food } from "../../domains/food/types";
import { FoodLog } from "../foodLog/types";
import { getRoundedMacros } from "../../utility";
import { Macros } from "../foodLog/types";
import { fetchGoogleAIResult } from "../../clients/googleClient";

// const completionResponse = async (prompt: string) => 
//     await openAiClient.completions.create({ model: MODEL, prompt, max_tokens:512, temperature: 0 });

/*
    NOTES on caching recent results 
        1. grab the first 50 foods generated by the user
        2. cache them locally on the device
        3. use auto completion feature on the items before performing any supabase look-ups
        4. beware of time complexity in <Array> vs <Object> especially with lookUps
*/

type AIResults = Macros & {
    name: string;
};

const MAX_RETRIES = 3;

const isValidData = (data: any) => {
    // Add validation logic for your data here, for example:
    return data && typeof data === 'object' &&  data.calories && data.fat && data.protein && data.carbs;
};

const getOpenAISearchResult = async (searchTerm: string, retryCount: number = 0): Promise<FetchMethod> => {
    try {
        const response = await fetchGptByText({ searchTerm });
        const generatedText = response?.choices?.[0]?.message?.function_call?.arguments;
        const data: AIResults  = generatedText ? JSON.parse(generatedText) : null;
        
        // Check if the data is valid
        if (!isValidData(data)) {
            // If not valid and we haven't reached our max retries, retry the function
            if (retryCount < MAX_RETRIES) {
                return getOpenAISearchResult(searchTerm, retryCount + 1);
            } else {
                // TODO: log the error
                // Max retries reached, return an error
                return { data: null, error: 'Maximum retries reached and data is still invalid.' };
            }
        }

        if(data) data.name = searchTerm;
        
        return { data, error: null };
    } catch (error) {
        return { data: null, error };
    }
};

const getAISearchResultByImage = async ({ base64Image }: {base64Image: string}) => {
    try {
        const response = await fetchGptByImage(base64Image);
        const prompt = response?.choices[0]?.message?.content;

        if(prompt) {
            const {data, error} = await getGoogleAISearchResult(prompt);
            if(data) data.name = prompt; // set data name with search term
            if(data) return { data, error: null }
            if(error) return { data: null, error }
        };
        return { data: null, error: 'Could not generate prompt'}
    } catch (error) {
        return { data: null, error }
    }
};

const getGoogleAISearchResult = async (searchTerm: string) => {
    try {
        let retryCount = 0
        const data = await fetchGoogleAIResult(searchTerm);
        if(!isValidData(data)){
            if (retryCount < MAX_RETRIES) {
                return getOpenAISearchResult(searchTerm, retryCount + 1);
            } else {
                // TODO: log the error
                // Max retries reached, return an error
                return { data: null, error: 'Maximum retries reached and data is still invalid.' };
            }
        }
        return { data, error: null };
    } catch (error) {
        return { error, data: null };
    }
}

type UseAISearchResult = Promise<{data: Food | null, error:string | null}> 


type UserFoodSearchParams = {
    recents: FoodLog[] | null | undefined;
    searchTerm: string;
    unit?: string;
    quantity?: number;
}

export const useFoodSearch = async ({ recents, searchTerm, unit, quantity } : UserFoodSearchParams): UseAISearchResult => {
    let foodParams: AIResults | null = null

    let error: string | null = null;
    const foodName = searchTerm.trim().toLocaleLowerCase();
    // check if food exists in recent logs;
    const recentFoodLog = recents?.find((item)=>item.food.name === foodName);
    if(recentFoodLog) foodParams = recentFoodLog?.food;

    // check if food is in the db
    if(!recentFoodLog){
      const { data, error: fetchFoodError }= await FoodService.fetchFoodByName({ foodName });
      if(data) foodParams = data
    };

    // get ai search result
    if(!foodParams) {
      const {data: newFood, error: searchError} = await getGoogleAISearchResult(foodName);
      foodParams = newFood;
      if(searchError) error = searchError;
    };

    // round off the macros
    if(foodParams) {
        foodParams = {
            ...foodParams,
            ...getRoundedMacros(foodParams)
        };
    };
    return { data: foodParams, error }
}

export default {
    getAISearchResultByImage,
    getGoogleAISearchResult,
    useFoodSearch,
}